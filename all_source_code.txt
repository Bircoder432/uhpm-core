==========================================
СОБРАННЫЙ ИСХОДНЫЙ КОД
Дата: Пн 17 ноя 2025 21:52:32 +05
Папка: /home/vstor/Projects/oss/myself/uhpm-core
==========================================

==========================================
ФАЙЛ: ./src/lib.rs
РАЗМЕР: 180 байт
==========================================
pub mod entities;
pub mod errors;
pub mod models;
pub mod paths;
pub mod ports;
pub mod repositories;

pub use entities::*;
pub use errors::*;
pub use models::*;
pub use ports::*;


==========================================
ФАЙЛ: ./src/repositories/mod.rs
РАЗМЕР: 238 байт
==========================================
pub mod database;
pub mod local_packages;
pub mod package_files;
pub mod remote_packages;

pub use local_packages::LocalPackagesRepository;
pub use package_files::PackageFilesRepository;
pub use remote_packages::RemotePackagesRepository;


==========================================
ФАЙЛ: ./src/repositories/package_files.rs
РАЗМЕР: 6768 байт
==========================================
use std::path::PathBuf;

use crate::{PackageId, Symlink, SymlinkType, UhpmError, ports::FileSystemOperations};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PackageMeta {
    pub name: String,
    pub version: String,
    pub author: String,
    pub description: Option<String>,
    pub dependencies: Vec<String>,
    pub provides: Option<Vec<String>>,
    pub conflicts: Option<Vec<String>>,
}

pub struct PackageFilesRepository<FS>
where
    FS: FileSystemOperations,
{
    file_system: FS,
    packages_dir: PathBuf,
}

impl<FS> PackageFilesRepository<FS>
where
    FS: FileSystemOperations,
{
    pub fn new(file_system: FS, packages_dir: PathBuf) -> Self {
        Self {
            file_system,
            packages_dir,
        }
    }

    pub fn get_package_path(&self, package_id: &PackageId) -> PathBuf {
        self.packages_dir.join(package_id.as_str())
    }

    pub fn get_package_meta_path(&self, package_id: &PackageId) -> PathBuf {
        self.get_package_path(package_id).join("meta.toml")
    }

    pub fn get_package_instlist_path(&self, package_id: &PackageId) -> PathBuf {
        self.get_package_path(package_id).join("instlist")
    }
}

impl<FS> PackageFilesRepository<FS>
where
    FS: FileSystemOperations + Send + Sync,
{
    pub async fn extract_package(
        &self,
        package_id: &PackageId,
        package_data: &[u8],
    ) -> Result<(), UhpmError> {
        let package_path = self.get_package_path(package_id);

        self.file_system.create_dir_all(&package_path).await?;

        // TODO

        let temp_path = package_path.join("package.uhp");
        self.file_system
            .write_file(&temp_path, package_data)
            .await?;

        // TODO

        Ok(())
    }

    pub async fn remove_package_files(&self, package_id: &PackageId) -> Result<(), UhpmError> {
        let package_path = self.get_package_path(package_id);

        if self.file_system.exists(&package_path).await {
            self.file_system.remove_dir_all(&package_path).await?;
        }

        Ok(())
    }

    pub async fn load_package_meta(
        &self,
        package_id: &PackageId,
    ) -> Result<Option<PackageMeta>, UhpmError> {
        let meta_path = self.get_package_meta_path(package_id);

        if !self.file_system.exists(&meta_path).await {
            return Ok(None);
        }

        let data = self.file_system.read_file(&meta_path).await?;
        let meta_str = std::str::from_utf8(&data)
            .map_err(|e| UhpmError::DeserializationError(e.to_string()))?;
        let meta: PackageMeta =
            toml::from_str(meta_str).map_err(|e| UhpmError::DeserializationError(e.to_string()))?;

        Ok(Some(meta))
    }

    pub async fn save_package_meta(
        &self,
        package_id: &PackageId,
        meta: &PackageMeta,
    ) -> Result<(), UhpmError> {
        let meta_path = self.get_package_meta_path(package_id);

        if let Some(parent) = meta_path.parent() {
            self.file_system.create_dir_all(parent).await?;
        }

        let toml_str =
            toml::to_string(meta).map_err(|e| UhpmError::SerializationError(e.to_string()))?;

        self.file_system
            .write_file(&meta_path, toml_str.as_bytes())
            .await?;
        Ok(())
    }

    pub async fn load_package_instlist(
        &self,
        package_id: &PackageId,
    ) -> Result<Vec<Symlink>, UhpmError> {
        let instlist_path = self.get_package_instlist_path(package_id);
        let package_path = self.get_package_path(package_id);

        if !self.file_system.exists(&instlist_path).await {
            return Ok(Vec::new());
        }

        let data = self.file_system.read_file(&instlist_path).await?;
        let content = std::str::from_utf8(&data)
            .map_err(|e| UhpmError::DeserializationError(e.to_string()))?;

        let mut symlinks = Vec::new();

        for line in content.lines() {
            let line = line.trim();

            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() == 2 {
                let source_relative = PathBuf::from(parts[0]);
                let target_absolute = PathBuf::from(parts[1]);

                let source_absolute = package_path.join(&source_relative);

                let link_type =
                    if let Ok(metadata) = self.file_system.metadata(&source_absolute).await {
                        if metadata.is_directory() {
                            SymlinkType::Directory
                        } else {
                            SymlinkType::File
                        }
                    } else {
                        SymlinkType::File
                    };

                let symlink = Symlink::new(source_absolute, target_absolute, link_type);
                symlinks.push(symlink);
            }
        }

        Ok(symlinks)
    }

    pub async fn create_symlinks_from_instlist(
        &self,
        package_id: &PackageId,
    ) -> Result<Vec<Symlink>, UhpmError> {
        let symlinks = self.load_package_instlist(package_id).await?;

        for symlink in &symlinks {
            if let Some(parent) = symlink.target.parent() {
                self.file_system.create_dir_all(parent).await?;
            }

            self.file_system.create_symlink(symlink).await?;
        }

        Ok(symlinks)
    }

    pub async fn copy_files_direct(&self, package_id: &PackageId) -> Result<(), UhpmError> {
        let symlinks = self.load_package_instlist(package_id).await?;

        for symlink in symlinks {
            if let Some(parent) = symlink.target.parent() {
                self.file_system.create_dir_all(parent).await?;
            }

            self.file_system
                .copy_file(&symlink.source, &symlink.target)
                .await?;
        }

        Ok(())
    }

    pub async fn remove_installation_files(&self, package_id: &PackageId) -> Result<(), UhpmError> {
        let symlinks = self.load_package_instlist(package_id).await?;

        for symlink in symlinks {
            if self.file_system.exists(&symlink.target).await {
                if self.file_system.is_symlink(&symlink.target).await {
                    self.file_system.remove_symlink(&symlink.target).await?;
                } else {
                    self.file_system.remove(&symlink.target).await?;
                }
            }
        }

        Ok(())
    }

    pub async fn package_exists(&self, package_id: &PackageId) -> bool {
        let package_path = self.get_package_path(package_id);
        self.file_system.exists(&package_path).await
    }
}


==========================================
ФАЙЛ: ./src/repositories/local_packages.rs
РАЗМЕР: 5657 байт
==========================================
use crate::{
    Dependency, Package, PackageReference, Repository, RepositoryIndex, UhpmError,
    paths::UhpmPaths,
    ports::{FileSystemOperations, PackageRepository},
};
use async_trait::async_trait;
use semver::Version;
use std::path::PathBuf;

pub struct LocalPackagesRepository<FS, P>
where
    FS: FileSystemOperations,
    P: UhpmPaths,
{
    file_system: FS,
    paths: P,
    repository: Repository,
}

impl<FS, P> LocalPackagesRepository<FS, P>
where
    FS: FileSystemOperations,
    P: UhpmPaths,
{
    pub fn new(file_system: FS, paths: P, repository: Repository) -> Result<Self, UhpmError> {
        Ok(Self {
            file_system,
            paths,
            repository,
        })
    }

    fn get_package_meta_path(&self, package_ref: &PackageReference) -> PathBuf {
        self.paths
            .packages_dir()
            .join(&package_ref.name)
            .join(&package_ref.version.to_string())
            .join("meta.toml")
    }
}

#[async_trait]
impl<FS, P> PackageRepository for LocalPackagesRepository<FS, P>
where
    FS: FileSystemOperations + Send + Sync,
    P: UhpmPaths + Send + Sync,
{
    async fn get_package(&self, package_ref: &PackageReference) -> Result<Package, UhpmError> {
        let meta_path = self.get_package_meta_path(package_ref);

        if !self.file_system.exists(&meta_path).await {
            return Err(UhpmError::PackageNotFound(package_ref.to_string()));
        }

        // TODO
        Err(UhpmError::ValidationError("Not implemented".into()))
    }

    async fn search_packages(&self, query: &str) -> Result<Vec<Package>, UhpmError> {
        let packages_dir = self.paths.packages_dir();
        let mut results = Vec::new();

        if self.file_system.exists(&packages_dir).await {
            // TODO
        }

        Ok(results)
    }

    async fn get_package_versions(&self, package_name: &str) -> Result<Vec<String>, UhpmError> {
        let packages_dir = self.paths.packages_dir();
        let package_dir = packages_dir.join(package_name);
        let mut versions = Vec::new();

        if self.file_system.exists(&package_dir).await {
            if let Ok(entries) = self.file_system.read_dir(&package_dir).await {
                for entry in entries {
                    if let Some(version_str) = entry.file_name().and_then(|n| n.to_str()) {
                        if Version::parse(version_str).is_ok() {
                            versions.push(version_str.to_string());
                        }
                    }
                }
            }
        }

        versions.sort_by(|a, b| Version::parse(a).unwrap().cmp(&Version::parse(b).unwrap()));

        Ok(versions)
    }

    async fn get_latest_version(&self, package_name: &str) -> Result<String, UhpmError> {
        let versions = self.get_package_versions(package_name).await?;
        versions
            .last()
            .cloned()
            .ok_or_else(|| UhpmError::PackageNotFound(package_name.to_string()))
    }

    async fn resolve_dependencies(
        &self,
        dependencies: &[Dependency],
    ) -> Result<Vec<Package>, UhpmError> {
        let mut resolved_packages = Vec::new();

        for dependency in dependencies {
            let versions = self.get_package_versions(&dependency.name).await?;

            if let Some(version_str) = versions.into_iter().rev().find(|v| {
                Version::parse(v)
                    .map(|ver| dependency.matches_version(&ver))
                    .unwrap_or(false)
            }) {
                let version = Version::parse(&version_str)
                    .map_err(|e| UhpmError::ValidationError(e.to_string()))?;

                let package_ref = PackageReference::new(dependency.name.clone(), version);
                let package = self.get_package(&package_ref).await?;
                resolved_packages.push(package);
            }
        }

        Ok(resolved_packages)
    }

    async fn download_package(&self, package_ref: &PackageReference) -> Result<Vec<u8>, UhpmError> {
        let meta_path = self.get_package_meta_path(package_ref);
        if !self.file_system.exists(&meta_path).await {
            return Err(UhpmError::PackageNotFound(package_ref.to_string()));
        }

        // TODO
        Ok(Vec::new())
    }

    async fn get_index(&self) -> Result<RepositoryIndex, UhpmError> {
        let packages_dir = self.paths.packages_dir();
        let mut packages = Vec::new();

        if self.file_system.exists(&packages_dir).await {
            if let Ok(entries) = self.file_system.read_dir(&packages_dir).await {
                for package_dir in entries {
                    if let Some(package_name) = package_dir.file_name().and_then(|n| n.to_str()) {
                        let versions = self.get_package_versions(package_name).await?;
                        if !versions.is_empty() {
                            packages.push(crate::RepositoryPackageEntry {
                                name: package_name.to_string(),
                                versions,
                            });
                        }
                    }
                }
            }
        }

        Ok(RepositoryIndex {
            name: "local".to_string(),
            url: packages_dir.to_string_lossy().to_string(),
            packages,
        })
    }

    async fn update_index(&self) -> Result<RepositoryIndex, UhpmError> {
        self.get_index().await
    }

    async fn is_available(&self) -> bool {
        self.file_system.exists(&self.paths.packages_dir()).await
    }

    fn get_repository(&self) -> &Repository {
        &self.repository
    }
}


==========================================
ФАЙЛ: ./src/repositories/remote_packages.rs
РАЗМЕР: 6564 байт
==========================================
use crate::{
    Dependency, Package, PackageReference, Repository, RepositoryIndex, UhpmError,
    paths::UhpmPaths,
    ports::{CacheManager, FileSystemOperations, NetworkOperations, PackageRepository},
};
use async_trait::async_trait;
use semver::Version;

pub struct RemotePackagesRepository<NET, CACHE, FS, P>
where
    NET: NetworkOperations,
    CACHE: CacheManager,
    FS: FileSystemOperations,
    P: UhpmPaths,
{
    network: NET,
    cache: CACHE,
    file_system: FS,
    paths: P,
    repository: Repository,
    base_url: String,
}

impl<NET, CACHE, FS, P> RemotePackagesRepository<NET, CACHE, FS, P>
where
    NET: NetworkOperations,
    CACHE: CacheManager,
    FS: FileSystemOperations,
    P: UhpmPaths,
{
    pub fn new(
        network: NET,
        cache: CACHE,
        file_system: FS,
        paths: P,
        repository: Repository,
    ) -> Result<Self, UhpmError> {
        let base_url = match &repository {
            Repository::Http { index_url } => index_url.clone(),
            _ => {
                return Err(UhpmError::ValidationError(
                    "RemotePackagesRepository requires HTTP repository".into(),
                ));
            }
        };

        Ok(Self {
            network,
            cache,
            file_system,
            paths,
            repository,
            base_url,
        })
    }

    fn get_package_meta_url(&self, package_ref: &PackageReference) -> String {
        format!(
            "{}/packages/{}-{}-meta.toml",
            self.base_url.trim_end_matches('/'),
            package_ref.name,
            package_ref.version
        )
    }

    fn get_package_download_url(&self, package_ref: &PackageReference) -> String {
        format!(
            "{}/packages/{}-{}.uhp",
            self.base_url.trim_end_matches('/'),
            package_ref.name,
            package_ref.version
        )
    }

    fn get_index_url(&self) -> String {
        format!("{}/index.toml", self.base_url.trim_end_matches('/'))
    }
}

#[async_trait]
impl<NET, CACHE, FS, P> PackageRepository for RemotePackagesRepository<NET, CACHE, FS, P>
where
    NET: NetworkOperations + Send + Sync,
    CACHE: CacheManager + Send + Sync,
    FS: FileSystemOperations + Send + Sync,
    P: UhpmPaths + Send + Sync,
{
    async fn get_package(&self, package_ref: &PackageReference) -> Result<Package, UhpmError> {
        // TODO
        Err(UhpmError::ValidationError("Not implemented".into()))
    }

    async fn search_packages(&self, query: &str) -> Result<Vec<Package>, UhpmError> {
        let index = self.get_index().await?;
        let mut results = Vec::new();

        for entry in index.packages {
            if entry.name.contains(query) {
                if let Some(latest_version) = entry.versions.last() {
                    let package_ref = PackageReference::new(
                        entry.name.clone(),
                        Version::parse(latest_version)
                            .map_err(|e| UhpmError::ValidationError(e.to_string()))?,
                    );
                    match self.get_package(&package_ref).await {
                        Ok(package) => results.push(package),
                        Err(_) => continue,
                    }
                }
            }
        }

        Ok(results)
    }

    async fn get_package_versions(&self, package_name: &str) -> Result<Vec<String>, UhpmError> {
        let index = self.get_index().await?;
        match index.get_versions(package_name) {
            Some(versions) => Ok(versions.to_vec()),
            None => Err(UhpmError::PackageNotFound(package_name.to_string())),
        }
    }

    async fn get_latest_version(&self, package_name: &str) -> Result<String, UhpmError> {
        let versions = self.get_package_versions(package_name).await?;
        versions
            .last()
            .cloned()
            .ok_or_else(|| UhpmError::PackageNotFound(package_name.to_string()))
    }

    async fn resolve_dependencies(
        &self,
        dependencies: &[Dependency],
    ) -> Result<Vec<Package>, UhpmError> {
        let mut resolved_packages = Vec::new();
        let index = self.get_index().await?;

        for dependency in dependencies {
            if let Some(version_str) = index.latest_satisfying(dependency) {
                let version = Version::parse(&version_str)
                    .map_err(|e| UhpmError::ValidationError(e.to_string()))?;

                let package_ref = PackageReference::new(dependency.name.clone(), version);
                let package = self.get_package(&package_ref).await?;
                resolved_packages.push(package);
            }
        }

        Ok(resolved_packages)
    }

    async fn download_package(&self, package_ref: &PackageReference) -> Result<Vec<u8>, UhpmError> {
        if let Some(cached_data) = self.cache.get_package(package_ref).await? {
            return Ok(cached_data);
        }

        let download_url = self.get_package_download_url(package_ref);
        let data = self.network.get(&download_url).await?;

        self.cache.put_package(package_ref, &data).await?;

        Ok(data)
    }

    async fn get_index(&self) -> Result<RepositoryIndex, UhpmError> {
        if let Some(cached_data) = self.cache.get_index(&self.base_url).await? {
            let index_str = std::str::from_utf8(&cached_data)
                .map_err(|e| UhpmError::DeserializationError(e.to_string()))?;
            let index: RepositoryIndex = toml::from_str(index_str)
                .map_err(|e| UhpmError::DeserializationError(e.to_string()))?;
            return Ok(index);
        }

        let index_url = self.get_index_url();
        let data = self.network.get(&index_url).await?;
        let index_str = std::str::from_utf8(&data)
            .map_err(|e| UhpmError::DeserializationError(e.to_string()))?;

        let index: RepositoryIndex = toml::from_str(index_str)
            .map_err(|e| UhpmError::DeserializationError(e.to_string()))?;

        self.cache.put_index(&self.base_url, &data).await?;

        Ok(index)
    }

    async fn update_index(&self) -> Result<RepositoryIndex, UhpmError> {
        self.cache.put_index(&self.base_url, &[]).await?;
        self.get_index().await
    }

    async fn is_available(&self) -> bool {
        match self.network.head(&self.get_index_url()).await {
            Ok(response) => response.status().is_success(),
            Err(_) => false,
        }
    }

    fn get_repository(&self) -> &Repository {
        &self.repository
    }
}


==========================================
ФАЙЛ: ./src/repositories/database.rs
РАЗМЕР: 4511 байт
==========================================
use crate::{FileMetadata, Installation, Package, PackageId, UhpmError};
use rusqlite::Connection;
use std::path::PathBuf;

pub struct DatabaseRepository {
    connection: Connection,
}

impl DatabaseRepository {
    pub fn new(db_path: PathBuf) -> Result<Self, UhpmError> {
        let connection =
            Connection::open(db_path).map_err(|e| UhpmError::DatabaseError(e.to_string()))?;

        let repo = Self { connection };
        repo.init_tables()?;

        Ok(repo)
    }

    fn init_tables(&self) -> Result<(), UhpmError> {
        self.connection
            .execute(
                "CREATE TABLE IF NOT EXISTS packages (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                version TEXT NOT NULL,
                author TEXT NOT NULL,
                source_type TEXT NOT NULL,
                source_path TEXT,
                target_os TEXT NOT NULL,
                target_arch TEXT NOT NULL,
                checksum_algorithm TEXT,
                checksum_hash TEXT,
                installed BOOLEAN NOT NULL DEFAULT 0,
                active BOOLEAN NOT NULL DEFAULT 0,
                installed_at DATETIME,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )",
                [],
            )
            .map_err(|e| UhpmError::DatabaseError(e.to_string()))?;

        self.connection
            .execute(
                "CREATE TABLE IF NOT EXISTS installed_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                package_id TEXT NOT NULL,
                installation_id TEXT NOT NULL,
                file_path TEXT NOT NULL,
                file_size INTEGER NOT NULL,
                checksum_algorithm TEXT,
                checksum_hash TEXT,
                permissions_read BOOLEAN NOT NULL,
                permissions_write BOOLEAN NOT NULL,
                permissions_execute BOOLEAN NOT NULL,
                file_type TEXT NOT NULL,
                created_at DATETIME NOT NULL,
                modified_at DATETIME NOT NULL,
                FOREIGN KEY (package_id) REFERENCES packages (id),
                FOREIGN KEY (installation_id) REFERENCES installations (installation_id)
            )",
                [],
            )
            .map_err(|e| UhpmError::DatabaseError(e.to_string()))?;

        self.connection
            .execute(
                "CREATE TABLE IF NOT EXISTS installations (
                installation_id TEXT PRIMARY KEY,
                package_id TEXT NOT NULL,
                installed_at DATETIME NOT NULL,
                active BOOLEAN NOT NULL DEFAULT 0,
                install_mode TEXT NOT NULL,
                FOREIGN KEY (package_id) REFERENCES packages (id)
            )",
                [],
            )
            .map_err(|e| UhpmError::DatabaseError(e.to_string()))?;

        self.connection
            .execute(
                "CREATE TABLE IF NOT EXISTS symlinks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                installation_id TEXT NOT NULL,
                source_path TEXT NOT NULL,
                target_path TEXT NOT NULL,
                link_type TEXT NOT NULL,
                created_at DATETIME NOT NULL,
                FOREIGN KEY (installation_id) REFERENCES installations (installation_id)
            )",
                [],
            )
            .map_err(|e| UhpmError::DatabaseError(e.to_string()))?;

        Ok(())
    }

    pub fn save_package(&self, package: &Package) -> Result<(), UhpmError> {
        // TODO

        Ok(())
    }

    pub fn get_package(&self, package_id: &PackageId) -> Result<Option<Package>, UhpmError> {
        // TODO
        Ok(None)
    }

    pub fn get_installed_packages(&self) -> Result<Vec<Package>, UhpmError> {
        // TODO
        Ok(Vec::new())
    }

    pub fn save_installation(&self, installation: &Installation) -> Result<(), UhpmError> {
        // TODO
        Ok(())
    }

    pub fn get_installation(
        &self,
        installation_id: &str,
    ) -> Result<Option<Installation>, UhpmError> {
        // TODO
        Ok(None)
    }

    pub fn save_installed_files(
        &self,
        installation_id: &str,
        files: &[(PathBuf, FileMetadata)],
    ) -> Result<(), UhpmError> {
        // TODO
        Ok(())
    }

    pub fn get_installed_files(
        &self,
        installation_id: &str,
    ) -> Result<Vec<(PathBuf, FileMetadata)>, UhpmError> {
        // TODO
        Ok(Vec::new())
    }
}


==========================================
ФАЙЛ: ./src/services/mod.rs
РАЗМЕР: 0 байт
==========================================


==========================================
ФАЙЛ: ./src/errors.rs
РАЗМЕР: 3050 байт
==========================================
use std::path::PathBuf;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum UhpmError {
    // Domain Errors
    #[error("Package `{0}` not found")]
    PackageNotFound(String),

    #[error("Installation `{0}` not found")]
    InstallationNotFound(String),

    #[error("No version of `{package}` matches `{required}`")]
    VersionMismatch {
        package: String,
        required: semver::VersionReq,
    },

    #[error("Dependency resolution failed: {0}")]
    ResolutionError(String),

    #[error("Dependency conflict: {0}")]
    DependencyConflict(String),

    #[error("Repository unreachable: {0}")]
    RepositoryUnavailable(String),

    #[error("Package already installed: {0}")]
    PackageAlreadyInstalled(String),

    #[error("No newer version available for package: {0}")]
    NoNewVersion(String),

    #[error("Package is currently active and cannot be removed")]
    PackageIsActive,

    // Validation Errors
    #[error("Validation error: {0}")]
    ValidationError(String),

    #[error("Invalid package format in `{0}`")]
    InvalidPackage(PathBuf),

    #[error("Checksum verification failed for package: {0}")]
    ChecksumMismatch(String),

    #[error("Unsupported target platform: {0}")]
    UnsupportedTarget(String),

    // Installation Errors
    #[error("Installation failed: {0}")]
    InstallationError(String),

    #[error("Failed to create symbolic link: {0}")]
    SymlinkError(String),

    #[error("Failed to remove package files: {0}")]
    RemovalError(String),

    #[error("Version switch failed: {0}")]
    SwitchError(String),

    // Network Errors
    #[error("Network error: {0}")]
    NetworkError(String),

    #[error("Download failed: {0}")]
    DownloadError(String),

    #[error("Repository index corrupted: {0}")]
    RepositoryCorrupted(String),

    // Storage Errors
    #[error("Database error: {0}")]
    DatabaseError(String),

    #[error("Storage error: {0}")]
    StorageError(String),

    #[error("Cache error: {0}")]
    CacheError(String),

    // Configuration Errors
    #[error("Configuration error: {0}")]
    ConfigError(String),

    #[error("Invalid configuration: {0}")]
    InvalidConfig(String),

    // File System Errors
    #[error("Failed to read file: {0}")]
    IoError(#[from] std::io::Error),

    #[error("File system error: {0}")]
    FileSystemError(String),

    #[error("Insufficient permissions: {0}")]
    PermissionError(String),

    // Serialization Errors
    #[error("Serialization error: {0}")]
    SerializationError(String),

    #[error("Deserialization error: {0}")]
    DeserializationError(String),

    // External Errors
    #[error("External tool error: {0}")]
    ExternalToolError(String),
}

impl UhpmError {
    pub fn validation<S: Into<String>>(msg: S) -> Self {
        Self::ValidationError(msg.into())
    }

    pub fn installation<S: Into<String>>(msg: S) -> Self {
        Self::InstallationError(msg.into())
    }

    pub fn network<S: Into<String>>(msg: S) -> Self {
        Self::NetworkError(msg.into())
    }
}


==========================================
ФАЙЛ: ./src/ports/mod.rs
РАЗМЕР: 484 байт
==========================================
// src/ports/mod.rs

pub use cache_manager::CacheManager;
pub use dependency_resolver::DependencyResolver;
pub use event_publisher::EventPublisher;
pub use file_system::FileSystemOperations;
pub use network::NetworkOperations;
pub use package_manager::PackageManager;
pub use package_repository::PackageRepository;

pub mod cache_manager;
pub mod dependency_resolver;
pub mod event_publisher;
pub mod file_system;
pub mod network;
pub mod package_manager;
pub mod package_repository;


==========================================
ФАЙЛ: ./src/ports/package_manager.rs
РАЗМЕР: 1253 байт
==========================================
use crate::{Dependency, Installation, Package, PackageReference, UhpmConfig, UhpmError};
use async_trait::async_trait;

#[async_trait]
pub trait PackageManager: Send + Sync {
    async fn install(&self, package_ref: &PackageReference) -> Result<Package, UhpmError>;

    async fn uninstall(&self, package_ref: &PackageReference) -> Result<(), UhpmError>;

    async fn update(&self, package_ref: &PackageReference) -> Result<Package, UhpmError>;

    async fn search(&self, query: &str) -> Result<Vec<Package>, UhpmError>;

    async fn info(&self, package_ref: &PackageReference) -> Result<Package, UhpmError>;

    async fn resolve_dependencies(
        &self,
        dependencies: &[Dependency],
    ) -> Result<Vec<Package>, UhpmError>;

    async fn list_installed(&self) -> Result<Vec<Package>, UhpmError>;

    async fn check_updates(&self) -> Result<Vec<PackageReference>, UhpmError>;

    async fn activate(&self, package_ref: &PackageReference) -> Result<(), UhpmError>;

    async fn deactivate(&self, package_ref: &PackageReference) -> Result<(), UhpmError>;

    fn get_config(&self) -> &UhpmConfig;

    async fn get_installation(
        &self,
        package_ref: &PackageReference,
    ) -> Result<Option<Installation>, UhpmError>;
}


==========================================
ФАЙЛ: ./src/ports/package_repository.rs
РАЗМЕР: 1014 байт
==========================================
use crate::{Dependency, Package, PackageReference, Repository, RepositoryIndex, UhpmError};
use async_trait::async_trait;

#[async_trait]
pub trait PackageRepository: Send + Sync {
    async fn get_package(&self, package_ref: &PackageReference) -> Result<Package, UhpmError>;

    async fn search_packages(&self, query: &str) -> Result<Vec<Package>, UhpmError>;

    async fn get_package_versions(&self, package_name: &str) -> Result<Vec<String>, UhpmError>;

    async fn get_latest_version(&self, package_name: &str) -> Result<String, UhpmError>;

    async fn resolve_dependencies(
        &self,
        dependencies: &[Dependency],
    ) -> Result<Vec<Package>, UhpmError>;

    async fn download_package(&self, package_ref: &PackageReference) -> Result<Vec<u8>, UhpmError>;

    async fn get_index(&self) -> Result<RepositoryIndex, UhpmError>;

    async fn update_index(&self) -> Result<RepositoryIndex, UhpmError>;

    async fn is_available(&self) -> bool;

    fn get_repository(&self) -> &Repository;
}


==========================================
ФАЙЛ: ./src/ports/file_system.rs
РАЗМЕР: 1371 байт
==========================================
use crate::{FileMetadata, Symlink, UhpmError};
use async_trait::async_trait;
use std::path::{Path, PathBuf};

#[async_trait]
pub trait FileSystemOperations: Send + Sync {
    async fn read_file(&self, path: &Path) -> Result<Vec<u8>, UhpmError>;

    async fn write_file(&self, path: &Path, data: &[u8]) -> Result<(), UhpmError>;

    async fn create_dir(&self, path: &Path) -> Result<(), UhpmError>;

    async fn create_dir_all(&self, path: &Path) -> Result<(), UhpmError>;

    async fn remove(&self, path: &Path) -> Result<(), UhpmError>;

    async fn remove_dir_all(&self, path: &Path) -> Result<(), UhpmError>;

    async fn copy_file(&self, from: &Path, to: &Path) -> Result<(), UhpmError>;

    async fn move_file(&self, from: &Path, to: &Path) -> Result<(), UhpmError>;

    async fn exists(&self, path: &Path) -> bool;

    async fn metadata(&self, path: &Path) -> Result<FileMetadata, UhpmError>;

    async fn read_dir(&self, path: &Path) -> Result<Vec<PathBuf>, UhpmError>;

    async fn create_symlink(&self, symlink: &Symlink) -> Result<(), UhpmError>;

    async fn remove_symlink(&self, path: &Path) -> Result<(), UhpmError>;

    async fn read_symlink(&self, path: &Path) -> Result<PathBuf, UhpmError>;

    async fn is_symlink(&self, path: &Path) -> bool;

    async fn set_permissions(&self, path: &Path, permissions: u32) -> Result<(), UhpmError>;
}


==========================================
ФАЙЛ: ./src/ports/network.rs
РАЗМЕР: 800 байт
==========================================
use crate::UhpmError;
use async_trait::async_trait;
use reqwest::Response;
use url::Url;

#[async_trait]
pub trait NetworkOperations: Send + Sync {
    async fn get(&self, url: &str) -> Result<Vec<u8>, UhpmError>;

    async fn get_with_progress(
        &self,
        url: &str,
        on_progress: Option<Box<dyn Fn(u64, u64) + Send + Sync>>,
    ) -> Result<Vec<u8>, UhpmError>;

    async fn head(&self, url: &str) -> Result<Response, UhpmError>;

    async fn is_url_available(&self, url: &str) -> bool;

    async fn download_with_checksum(
        &self,
        url: &str,
        expected_checksum: Option<(&str, &str)>,
        on_progress: Option<Box<dyn Fn(u64, u64) + Send + Sync>>,
    ) -> Result<Vec<u8>, UhpmError>;

    fn parse_url(&self, url: &str) -> Result<Url, UhpmError>;
}


==========================================
ФАЙЛ: ./src/ports/cache_manager.rs
РАЗМЕР: 1044 байт
==========================================
use crate::{PackageReference, UhpmError};
use async_trait::async_trait;
use std::path::PathBuf;
use std::time::Duration;

#[async_trait]
pub trait CacheManager: Send + Sync {
    async fn get_package(
        &self,
        package_ref: &PackageReference,
    ) -> Result<Option<Vec<u8>>, UhpmError>;

    async fn put_package(
        &self,
        package_ref: &PackageReference,
        data: &[u8],
    ) -> Result<(), UhpmError>;

    async fn remove_package(&self, package_ref: &PackageReference) -> Result<(), UhpmError>;

    async fn clear_packages(&self) -> Result<(), UhpmError>;

    async fn get_index(&self, repository_url: &str) -> Result<Option<Vec<u8>>, UhpmError>;

    async fn put_index(&self, repository_url: &str, data: &[u8]) -> Result<(), UhpmError>;

    async fn get_cache_size(&self) -> Result<u64, UhpmError>;

    async fn cleanup_old_entries(&self, max_age: Duration) -> Result<(), UhpmError>;

    fn get_cache_path(&self) -> &PathBuf;

    async fn has_package(&self, package_ref: &PackageReference) -> bool;
}


==========================================
ФАЙЛ: ./src/ports/event_publisher.rs
РАЗМЕР: 600 байт
==========================================
use crate::PackageEvent;
use crate::UhpmError;
use async_trait::async_trait;

#[async_trait]
pub trait EventPublisher: Send + Sync {
    async fn publish(&self, event: PackageEvent) -> Result<(), UhpmError>;

    async fn subscribe(
        &self,
        callback: Box<dyn Fn(PackageEvent) + Send + Sync>,
    ) -> Result<String, UhpmError>;

    async fn unsubscribe(&self, subscription_id: &str) -> Result<(), UhpmError>;

    async fn get_event_history(&self, limit: Option<usize>)
    -> Result<Vec<PackageEvent>, UhpmError>;

    async fn clear_event_history(&self) -> Result<(), UhpmError>;
}


==========================================
ФАЙЛ: ./src/ports/dependency_resolver.rs
РАЗМЕР: 1180 байт
==========================================
use crate::{
    Dependency, DependencyConflict, Package, PackageReference, ResolutionResult, UhpmError,
};
use async_trait::async_trait;
use std::collections::HashMap;

#[async_trait]
pub trait DependencyResolver: Send + Sync {
    async fn resolve_for_installation(
        &self,
        package_ref: &PackageReference,
        installed_packages: &[Package],
    ) -> Result<ResolutionResult, UhpmError>;

    async fn resolve_for_update(
        &self,
        package_ref: &PackageReference,
        installed_packages: &[Package],
    ) -> Result<ResolutionResult, UhpmError>;

    async fn resolve_for_removal(
        &self,
        package_ref: &PackageReference,
        installed_packages: &[Package],
    ) -> Result<ResolutionResult, UhpmError>;

    async fn check_conflicts(
        &self,
        packages: &[Package],
    ) -> Result<Vec<DependencyConflict>, UhpmError>;

    async fn find_satisfying_versions(
        &self,
        dependency: &Dependency,
    ) -> Result<Vec<Package>, UhpmError>;

    async fn build_dependency_graph(
        &self,
        root_packages: &[PackageReference],
    ) -> Result<HashMap<String, Vec<Dependency>>, UhpmError>;
}


==========================================
ФАЙЛ: ./src/models/dependency.rs
РАЗМЕР: 1548 байт
==========================================
use crate::{Package, PackageReference};
use semver::VersionReq;
use serde::{Deserialize, Serialize};
use std::hash::{Hash, Hasher};

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct Dependency {
    pub name: String,
    pub constraint: VersionConstraint,
    pub kind: DependencyKind,

    #[serde(default)]
    pub provides: Option<String>,

    #[serde(default)]
    pub features: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Hash)]
pub enum DependencyKind {
    Required,
    Optional,
    Build,
    Dev,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Hash)]
pub struct VersionConstraint {
    pub requirement: VersionReq,
}

#[derive(Debug, Clone)]
pub struct ResolutionResult {
    pub packages_to_install: Vec<Package>,

    pub packages_to_update: Vec<PackageReference>,

    pub packages_to_remove: Vec<PackageReference>,

    pub conflicts: Vec<DependencyConflict>,
}

#[derive(Debug, Clone)]
pub struct DependencyConflict {
    pub package: String,

    pub required: String,

    pub installed: String,

    pub message: String,
}

impl Dependency {
    pub fn matches_version(&self, version: &semver::Version) -> bool {
        self.constraint.requirement.matches(version)
    }
}

impl Hash for Dependency {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.name.hash(state);
        self.constraint.hash(state);
        std::mem::discriminant(&self.kind).hash(state);
        self.provides.hash(state);
        self.features.hash(state);
    }
}


==========================================
ФАЙЛ: ./src/models/repository.rs
РАЗМЕР: 1257 байт
==========================================
use crate::Dependency;
use semver::Version;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum Repository {
    Local { path: PathBuf },
    Http { index_url: String },
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct RepositoryIndex {
    pub name: String,
    pub url: String,
    pub packages: Vec<RepositoryPackageEntry>,
}

impl RepositoryIndex {
    pub fn get_versions(&self, pkg: &str) -> Option<&[String]> {
        self.packages
            .iter()
            .find(|p| p.name == pkg)
            .map(|p| p.versions.as_slice())
    }

    pub fn latest_satisfying(&self, dep: &Dependency) -> Option<String> {
        let versions = self.get_versions(&dep.name)?;
        let mut parsed: Vec<Version> = versions
            .iter()
            .filter_map(|v| Version::parse(v).ok())
            .collect();
        parsed.sort();
        parsed
            .into_iter()
            .rev()
            .find(|v| dep.matches_version(v))
            .map(|v| v.to_string())
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct RepositoryPackageEntry {
    pub name: String,
    pub versions: Vec<String>,
}


==========================================
ФАЙЛ: ./src/models/target.rs
РАЗМЕР: 723 байт
==========================================
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct Target {
    pub os: OperatingSystem,
    pub arch: Architecture,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum OperatingSystem {
    Linux,
    MacOS,
    Custom(String),
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum Architecture {
    X86_64,
    Aarch64,
    Custom(String),
}

impl Target {
    pub fn current() -> Self {
        Self {
            os: OperatingSystem::Linux,
            arch: Architecture::X86_64,
        }
    }

    pub fn matches(&self, other: &Target) -> bool {
        self.os == other.os && self.arch == other.arch
    }
}


==========================================
ФАЙЛ: ./src/models/mod.rs
РАЗМЕР: 321 байт
==========================================
pub mod config;
pub mod dependency;
pub mod events;
pub mod file_metadata;
pub mod operations;
pub mod repository;
pub mod symlink;
pub mod target;

pub use config::*;
pub use dependency::*;
pub use events::*;
pub use file_metadata::*;
pub use operations::*;
pub use repository::*;
pub use symlink::*;
pub use target::*;


==========================================
ФАЙЛ: ./src/models/operations.rs
РАЗМЕР: 203 байт
==========================================
use crate::PackageId;
use std::path::PathBuf;

#[derive(Debug, Clone)]
pub struct InstallResult {
    pub package_id: PackageId,
    pub installed_files: Vec<PathBuf>,
    pub symlinks_created: usize,
}


==========================================
ФАЙЛ: ./src/models/config.rs
РАЗМЕР: 4759 байт
==========================================
use crate::UhpmError;
use serde::{Deserialize, Serialize};
use std::fmt;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct UhpmConfig {
    pub update_source: String,
    pub default_install_mode: InstallMode,
    pub repositories: Vec<RepositoryConfig>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct RepositoryConfig {
    pub name: String,
    pub url: String,
    pub repo_type: RepositoryType,
    pub enabled: bool,
    pub priority: u32,
    pub authentication: Option<RepositoryAuth>,
}

impl RepositoryConfig {
    pub fn new<S: Into<String>>(name: S, url: S, repo_type: RepositoryType) -> Self {
        Self {
            name: name.into(),
            url: url.into(),
            repo_type,
            enabled: true,
            priority: 100,
            authentication: None,
        }
    }

    pub fn with_priority(mut self, priority: u32) -> Self {
        self.priority = priority;
        self
    }

    pub fn with_auth(mut self, auth: RepositoryAuth) -> Self {
        self.authentication = Some(auth);
        self
    }

    pub fn disabled(mut self) -> Self {
        self.enabled = false;
        self
    }

    pub fn is_local(&self) -> bool {
        self.url.starts_with("file://") || !self.url.contains("://")
    }

    pub fn is_remote(&self) -> bool {
        self.url.starts_with("http://") || self.url.starts_with("https://")
    }

    pub fn local_path(&self) -> Option<std::path::PathBuf> {
        if self.url.starts_with("file://") {
            Some(std::path::PathBuf::from(
                self.url.strip_prefix("file://").unwrap(),
            ))
        } else if !self.url.contains("://") {
            Some(std::path::PathBuf::from(&self.url))
        } else {
            None
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum RepositoryType {
    #[serde(rename = "binary")]
    Binary,
    #[serde(rename = "source")]
    Source,
    #[serde(rename = "universal")]
    Universal,
    #[serde(rename = "mixed")]
    Mixed,
}

impl fmt::Display for RepositoryType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Binary => write!(f, "binary"),
            Self::Source => write!(f, "source"),
            Self::Universal => write!(f, "universal"),
            Self::Mixed => write!(f, "mixed"),
        }
    }
}

impl Default for RepositoryType {
    fn default() -> Self {
        Self::Binary
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct RepositoryAuth {
    pub username: Option<String>,
    pub password: Option<String>,
    pub token: Option<String>,
}

impl RepositoryAuth {
    pub fn token<S: Into<String>>(token: S) -> Self {
        Self {
            username: None,
            password: None,
            token: Some(token.into()),
        }
    }

    pub fn basic<S: Into<String>>(username: S, password: S) -> Self {
        Self {
            username: Some(username.into()),
            password: Some(password.into()),
            token: None,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum InstallMode {
    #[serde(rename = "symlink")]
    Symlink,
    #[serde(rename = "direct")]
    Direct,
    #[serde(rename = "auto")]
    Auto,
}

impl InstallMode {
    pub fn is_direct(&self) -> bool {
        matches!(self, Self::Direct)
    }

    pub fn is_symlink(&self) -> bool {
        matches!(self, Self::Symlink)
    }

    pub fn is_auto(&self) -> bool {
        matches!(self, Self::Auto)
    }

    pub fn should_use_symlinks(&self, platform_supports_symlinks: bool) -> bool {
        match self {
            Self::Symlink => true,
            Self::Direct => false,
            Self::Auto => platform_supports_symlinks,
        }
    }
}

impl Default for InstallMode {
    fn default() -> Self {
        Self::Auto
    }
}

impl fmt::Display for InstallMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Symlink => write!(f, "symlink"),
            Self::Direct => write!(f, "direct"),
            Self::Auto => write!(f, "auto"),
        }
    }
}

impl TryFrom<&str> for InstallMode {
    type Error = UhpmError;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value.to_lowercase().as_str() {
            "symlink" | "symbolic" | "link" => Ok(Self::Symlink),
            "direct" | "copy" | "hard" => Ok(Self::Direct),
            "auto" | "automatic" => Ok(Self::Auto),
            _ => Err(UhpmError::validation(format!(
                "Invalid install mode: '{}'. Use 'symlink', 'direct', or 'auto'",
                value
            ))),
        }
    }
}


==========================================
ФАЙЛ: ./src/models/file_metadata.rs
РАЗМЕР: 4630 байт
==========================================
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::fmt;
use std::path::PathBuf;

use md5::Digest as Md5Digest;
use sha1::Digest as Sha1Digest;
use sha2::Digest as Sha2Digest;

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct FileMetadata {
    pub path: PathBuf,
    pub size: u64,
    pub checksum: Option<FileChecksum>,
    pub permissions: FilePermissions,
    pub created_at: DateTime<Utc>,
    pub modified_at: DateTime<Utc>,
    pub file_type: FileType,
}

impl FileMetadata {
    pub fn new(path: PathBuf, size: u64) -> Self {
        let now = Utc::now();
        Self {
            path,
            size,
            checksum: None,
            permissions: FilePermissions::default(),
            created_at: now,
            modified_at: now,
            file_type: FileType::Regular,
        }
    }

    pub fn with_checksum(mut self, algorithm: &str, hash: &str) -> Self {
        self.checksum = Some(FileChecksum {
            algorithm: algorithm.to_string(),
            hash: hash.to_string(),
        });
        self
    }

    pub fn with_permissions(mut self, permissions: FilePermissions) -> Self {
        self.permissions = permissions;
        self
    }

    pub fn with_file_type(mut self, file_type: FileType) -> Self {
        self.file_type = file_type;
        self
    }

    pub fn is_executable(&self) -> bool {
        self.permissions.is_executable()
    }

    pub fn is_symlink(&self) -> bool {
        matches!(self.file_type, FileType::Symlink)
    }

    pub fn is_directory(&self) -> bool {
        matches!(self.file_type, FileType::Directory)
    }

    pub fn verify_checksum(&self, data: &[u8]) -> Result<bool, crate::UhpmError> {
        if let Some(checksum) = &self.checksum {
            let actual_hash = match checksum.algorithm.as_str() {
                "sha256" => sha256_hash(data),
                "sha1" => sha1_hash(data),
                "md5" => md5_hash(data),
                algo => {
                    return Err(crate::UhpmError::ValidationError(format!(
                        "Unsupported checksum algorithm: {}",
                        algo
                    )));
                }
            };
            Ok(actual_hash == checksum.hash)
        } else {
            Ok(true)
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct FileChecksum {
    pub algorithm: String,
    pub hash: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct FilePermissions {
    pub read: bool,
    pub write: bool,
    pub execute: bool,
}

impl Default for FilePermissions {
    fn default() -> Self {
        Self {
            read: true,
            write: false,
            execute: false,
        }
    }
}

impl FilePermissions {
    pub fn executable() -> Self {
        Self {
            read: true,
            write: false,
            execute: true,
        }
    }

    pub fn read_only() -> Self {
        Self {
            read: true,
            write: false,
            execute: false,
        }
    }

    pub fn read_write() -> Self {
        Self {
            read: true,
            write: true,
            execute: false,
        }
    }

    pub fn is_executable(&self) -> bool {
        self.execute
    }

    pub fn octal(&self) -> u32 {
        let mut result = 0;
        if self.read {
            result |= 0o400;
        }
        if self.write {
            result |= 0o200;
        }
        if self.execute {
            result |= 0o100;
        }
        result
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum FileType {
    #[serde(rename = "regular")]
    Regular,
    #[serde(rename = "directory")]
    Directory,
    #[serde(rename = "symlink")]
    Symlink,
    #[serde(rename = "executable")]
    Executable,
}

impl fmt::Display for FileType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Regular => write!(f, "regular"),
            Self::Directory => write!(f, "directory"),
            Self::Symlink => write!(f, "symlink"),
            Self::Executable => write!(f, "executable"),
        }
    }
}

fn sha256_hash(data: &[u8]) -> String {
    use sha2::Sha256;
    let mut hasher = Sha256::new();
    hasher.update(data);
    format!("{:x}", hasher.finalize())
}

fn sha1_hash(data: &[u8]) -> String {
    use sha1::Sha1;
    let mut hasher = Sha1::new();
    hasher.update(data);
    format!("{:x}", hasher.finalize())
}

fn md5_hash(data: &[u8]) -> String {
    format!("{:x}", md5::compute(data))
}


==========================================
ФАЙЛ: ./src/models/symlink.rs
РАЗМЕР: 5834 байт
==========================================
use serde::{Deserialize, Serialize};
use std::fmt;
use std::hash::{Hash, Hasher};
use std::path::{Path, PathBuf};

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct Symlink {
    pub source: PathBuf,
    pub target: PathBuf,
    pub link_type: SymlinkType,
    pub metadata: SymlinkMetadata,
}

impl Symlink {
    pub fn new<S, T>(source: S, target: T, link_type: SymlinkType) -> Self
    where
        S: Into<PathBuf>,
        T: Into<PathBuf>,
    {
        Self {
            source: source.into(),
            target: target.into(),
            link_type,
            metadata: SymlinkMetadata::default(),
        }
    }

    pub fn file<S, T>(source: S, target: T) -> Self
    where
        S: Into<PathBuf>,
        T: Into<PathBuf>,
    {
        Self::new(source, target, SymlinkType::File)
    }

    pub fn directory<S, T>(source: S, target: T) -> Self
    where
        S: Into<PathBuf>,
        T: Into<PathBuf>,
    {
        Self::new(source, target, SymlinkType::Directory)
    }

    pub fn with_metadata(mut self, metadata: SymlinkMetadata) -> Self {
        self.metadata = metadata;
        self
    }

    pub fn is_file_link(&self) -> bool {
        matches!(self.link_type, SymlinkType::File)
    }

    pub fn is_directory_link(&self) -> bool {
        matches!(self.link_type, SymlinkType::Directory)
    }

    pub fn is_absolute(&self) -> bool {
        self.target.is_absolute()
    }

    pub fn is_relative(&self) -> bool {
        self.target.is_relative()
    }

    pub fn resolve_absolute_path(&self, base_dir: &Path) -> PathBuf {
        if self.target.is_absolute() {
            self.target.clone()
        } else {
            base_dir.join(&self.target)
        }
    }

    pub fn validate(&self) -> Result<(), crate::UhpmError> {
        if self.source.as_os_str().is_empty() {
            return Err(crate::UhpmError::validation(
                "Symlink source cannot be empty",
            ));
        }

        if self.target.as_os_str().is_empty() {
            return Err(crate::UhpmError::validation(
                "Symlink target cannot be empty",
            ));
        }

        if self.source == self.target {
            return Err(crate::UhpmError::validation(
                "Symlink source and target cannot be the same",
            ));
        }

        Ok(())
    }
}

impl Hash for Symlink {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.source.hash(state);
        self.target.hash(state);
        std::mem::discriminant(&self.link_type).hash(state);
        self.metadata.created_at.hash(state);
        self.metadata.owner.hash(state);
        self.metadata.group.hash(state);
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum SymlinkType {
    #[serde(rename = "file")]
    File,
    #[serde(rename = "directory")]
    Directory,
}

impl SymlinkType {
    pub fn is_file(&self) -> bool {
        matches!(self, Self::File)
    }

    pub fn is_directory(&self) -> bool {
        matches!(self, Self::Directory)
    }
}

impl Default for SymlinkType {
    fn default() -> Self {
        Self::File
    }
}

impl fmt::Display for SymlinkType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::File => write!(f, "file"),
            Self::Directory => write!(f, "directory"),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct SymlinkMetadata {
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub owner: Option<String>,
    pub group: Option<String>,
    pub description: Option<String>,
}

impl Default for SymlinkMetadata {
    fn default() -> Self {
        Self {
            created_at: chrono::Utc::now(),
            owner: None,
            group: None,
            description: None,
        }
    }
}

impl SymlinkMetadata {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_owner<S: Into<String>>(mut self, owner: S) -> Self {
        self.owner = Some(owner.into());
        self
    }

    pub fn with_group<S: Into<String>>(mut self, group: S) -> Self {
        self.group = Some(group.into());
        self
    }

    pub fn with_description<S: Into<String>>(mut self, description: S) -> Self {
        self.description = Some(description.into());
        self
    }
}

#[derive(Debug, Clone)]
pub struct SymlinkBatch {
    pub links: Vec<Symlink>,
    pub base_directory: PathBuf,
}

impl SymlinkBatch {
    pub fn new(base_directory: PathBuf) -> Self {
        Self {
            links: Vec::new(),
            base_directory,
        }
    }

    pub fn add_link(&mut self, symlink: Symlink) -> Result<(), crate::UhpmError> {
        symlink.validate()?;
        self.links.push(symlink);
        Ok(())
    }

    pub fn add_file_link<S, T>(&mut self, source: S, target: T) -> Result<(), crate::UhpmError>
    where
        S: Into<PathBuf>,
        T: Into<PathBuf>,
    {
        let symlink = Symlink::file(source, target);
        self.add_link(symlink)
    }

    pub fn add_directory_link<S, T>(&mut self, source: S, target: T) -> Result<(), crate::UhpmError>
    where
        S: Into<PathBuf>,
        T: Into<PathBuf>,
    {
        let symlink = Symlink::directory(source, target);
        self.add_link(symlink)
    }

    pub fn validate_all(&self) -> Result<(), crate::UhpmError> {
        for link in &self.links {
            link.validate()?;
        }

        let mut targets = std::collections::HashSet::new();
        for link in &self.links {
            if !targets.insert(&link.target) {
                return Err(crate::UhpmError::validation(format!(
                    "Duplicate symlink target: {}",
                    link.target.display()
                )));
            }
        }

        Ok(())
    }
}


==========================================
ФАЙЛ: ./src/models/events.rs
РАЗМЕР: 963 байт
==========================================
use crate::{Package, PackageReference};

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PackageEvent {
    InstallationStarted {
        package_ref: PackageReference,
    },

    InstallationCompleted {
        package: Package,
    },

    InstallationFailed {
        package_ref: PackageReference,
        error: String,
    },

    RemoveStarted {
        package_ref: PackageReference,
    },

    RemoveCompleted {
        package_ref: PackageReference,
    },

    UpdateStarted {
        package_ref: PackageReference,
    },

    UpdateCompleted {
        package: Package,
    },

    DownloadStarted {
        package_ref: PackageReference,
        size: Option<u64>,
    },

    DownloadProgress {
        package_ref: PackageReference,
        downloaded: u64,
        total: u64,
    },

    DownloadCompleted {
        package_ref: PackageReference,
    },

    DependencyResolved {
        dependency: String,
        package: Package,
    },
}


==========================================
ФАЙЛ: ./src/entities/mod.rs
РАЗМЕР: 85 байт
==========================================
pub mod installation;
pub mod package;

pub use installation::*;
pub use package::*;


==========================================
ФАЙЛ: ./src/entities/package.rs
РАЗМЕР: 4573 байт
==========================================
use crate::UhpmError;
use semver::Version;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::fmt;
use std::path::PathBuf;

use crate::Dependency;
use crate::Target;

#[derive(Debug, Clone, Eq)]
pub struct Package {
    id: PackageId,
    name: String,
    version: Version,
    author: String,
    source: PackageSource,
    target: Target,
    checksum: Option<Checksum>,
    dependencies: HashSet<Dependency>,
    installed: bool,
    active: bool,
}

impl Package {
    pub fn new(
        name: String,
        version: semver::Version,
        author: String,
        source: PackageSource,
        target: Target,
        checksum: Option<Checksum>,
        dependencies: Vec<Dependency>,
    ) -> Result<Self, crate::UhpmError> {
        if name.is_empty() {
            return Err(UhpmError::ValidationError(
                "Package name cannot be empty".into(),
            ));
        }

        let id = PackageId::new(&name, &version);
        let dependencies_set: HashSet<Dependency> = dependencies.into_iter().collect();

        Ok(Self {
            id,
            name,
            version,
            author,
            source,
            target,
            checksum,
            dependencies: dependencies_set,
            installed: false,
            active: false,
        })
    }

    pub fn mark_installed(&mut self) {
        self.installed = true;
    }

    pub fn mark_removed(&mut self) {
        self.installed = false;
        self.active = false;
    }

    pub fn activate(&mut self) {
        if self.installed {
            self.active = true;
        }
    }

    pub fn deactivate(&mut self) {
        self.active = false;
    }

    pub fn matches_target(&self, target: &Target) -> bool {
        self.target.matches(target)
    }

    pub fn has_dependency(&self, name: &str) -> bool {
        self.dependencies.iter().any(|d| d.name == name)
    }
    pub fn id(&self) -> &PackageId {
        &self.id
    }
    pub fn name(&self) -> &str {
        &self.name
    }
    pub fn version(&self) -> &semver::Version {
        &self.version
    }
    pub fn is_installed(&self) -> bool {
        self.installed
    }
    pub fn is_active(&self) -> bool {
        self.active
    }
    pub fn author(&self) -> &String {
        &self.author
    }
}

impl PartialEq for Package {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Clone)]
pub enum PackageSource {
    Git {
        url: String,
        release: Option<String>,
    },
    Http {
        url: String,
    },
    Local {
        path: PathBuf,
    },
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PackageId(String);

impl PackageId {
    pub fn new(name: &str, version: &semver::Version) -> Self {
        Self(format!("{}@{}", name, version))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Clone)]
pub struct Checksum {
    pub algorithm: String,
    pub hash: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Hash)]
pub struct PackageReference {
    pub name: String,
    pub version: Version,
}

impl PackageReference {
    pub fn new(name: String, version: Version) -> Self {
        Self { name, version }
    }

    pub fn from_package(package: &Package) -> Self {
        Self {
            name: package.name.clone(),
            version: package.version.clone(),
        }
    }

    pub fn id(&self) -> String {
        format!("{}@{}", self.name, self.version)
    }

    pub fn matches(&self, other: &PackageReference) -> bool {
        self.name == other.name && self.version == other.version
    }
}

impl fmt::Display for PackageReference {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}@{}", self.name, self.version)
    }
}

impl From<&Package> for PackageReference {
    fn from(package: &Package) -> Self {
        PackageReference::from_package(package)
    }
}

impl TryFrom<&str> for PackageReference {
    type Error = String;

    fn try_from(s: &str) -> Result<Self, Self::Error> {
        let parts: Vec<&str> = s.split('@').collect();
        if parts.len() != 2 {
            return Err(format!("Invalid package reference format: {}", s));
        }

        let name = parts[0].to_string();
        let version = Version::parse(parts[1])
            .map_err(|e| format!("Invalid version in package reference: {}", e))?;

        Ok(PackageReference::new(name, version))
    }
}


==========================================
ФАЙЛ: ./src/entities/installation.rs
РАЗМЕР: 2470 байт
==========================================
use crate::{FileMetadata, PackageId, Symlink, UhpmError};
use std::collections::HashMap;
use std::fmt;
use std::path::PathBuf;
use uuid::Uuid;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InstallationId(Uuid);

impl InstallationId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }

    pub fn from_uuid(uuid: Uuid) -> Self {
        Self(uuid)
    }

    pub fn as_uuid(&self) -> &Uuid {
        &self.0
    }

    pub fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl Default for InstallationId {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Display for InstallationId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<Uuid> for InstallationId {
    fn from(uuid: Uuid) -> Self {
        Self(uuid)
    }
}

impl TryFrom<&str> for InstallationId {
    type Error = crate::UhpmError;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        let uuid = Uuid::parse_str(value)
            .map_err(|e| UhpmError::ValidationError(format!("Invalid installation ID: {}", e)))?;
        Ok(Self(uuid))
    }
}

pub struct Installation {
    id: InstallationId,
    package_id: PackageId,
    installed_files: HashMap<PathBuf, FileMetadata>,
    symlinks: Vec<Symlink>,
    installed_at: chrono::DateTime<chrono::Utc>,
    active: bool,
}

impl Installation {
    pub fn new(package_id: PackageId) -> Self {
        Self {
            id: InstallationId::new(),
            package_id,
            installed_files: HashMap::new(),
            symlinks: Vec::new(),
            installed_at: chrono::Utc::now(),
            active: false,
        }
    }

    pub fn add_installed_file(&mut self, path: PathBuf, metadata: FileMetadata) {
        self.installed_files.insert(path, metadata);
    }

    pub fn add_symlink(&mut self, symlink: Symlink) {
        self.symlinks.push(symlink);
    }

    pub fn activate(&mut self) {
        self.active = true;
    }

    pub fn deactivate(&mut self) {
        self.active = false;
    }

    pub fn verify_integrity(&self) -> Result<(), crate::UhpmError> {
        for (path, metadata) in &self.installed_files {
            if !path.exists() {
                return Err(UhpmError::InstallationError(format!(
                    "Missing installed file: {}",
                    path.display()
                )));
            }
            // TODO
        }
        Ok(())
    }
}


==========================================
ФАЙЛ: ./src/paths.rs
РАЗМЕР: 1040 байт
==========================================
use crate::UhpmError;
use std::path::PathBuf;

pub trait UhpmPaths: Send + Sync {
    fn base_dir(&self) -> PathBuf;

    fn packages_dir(&self) -> PathBuf {
        self.base_dir().join("packages")
    }

    fn db_path(&self) -> PathBuf {
        self.base_dir().join("packages.db")
    }

    fn config_path(&self) -> PathBuf;

    fn cache_dir(&self) -> PathBuf;

    fn temp_dir(&self) -> PathBuf;

    fn log_dir(&self) -> PathBuf {
        self.base_dir().join("logs")
    }

    async fn create_directories<FS: crate::ports::FileSystemOperations>(
        &self,
        fs: &FS,
    ) -> Result<(), UhpmError> {
        fs.create_dir_all(&self.base_dir()).await?;
        fs.create_dir_all(&self.packages_dir()).await?;
        fs.create_dir_all(&self.cache_dir()).await?;
        fs.create_dir_all(&self.temp_dir()).await?;
        fs.create_dir_all(&self.log_dir()).await?;

        if let Some(config_parent) = self.config_path().parent() {
            fs.create_dir_all(config_parent).await?;
        }

        Ok(())
    }
}


==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-478c1bc74b831b2d/lib-uhpm_core.json
РАЗМЕР: 354 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":17672942494452627365,"path":10763286916239946207,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-478c1bc74b831b2d/dep-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-7930f98eb6d8d79a/test-lib-uhpm_core.json
РАЗМЕР: 358 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":3316208278650011218,"path":10763286916239946207,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-7930f98eb6d8d79a/dep-test-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde_core-4a432be80d75a511/run-build-script-build-script-build.json
РАЗМЕР: 332 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[11899261697793765154,"build_script_build",false,11328593659850488396]],"local":[{"RerunIfChanged":{"output":"debug/build/serde_core-4a432be80d75a511/output","paths":["build.rs"]}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde_core-95aeb14dc67bca28/build-script-build-script-build.json
РАЗМЕР: 435 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"alloc\", \"default\", \"rc\", \"result\", \"std\", \"unstable\"]","target":5408242616063297496,"profile":2225463790103693989,"path":1417144236825141019,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_core-95aeb14dc67bca28/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-25562388f26c67fe/lib-uhpm_core.json
РАЗМЕР: 412 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":17672942494452627365,"path":10763286916239946207,"deps":[[18361894353739432590,"semver",false,14561842533847925745]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-25562388f26c67fe/dep-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/semver-407364a4d93478f4/lib-semver.json
РАЗМЕР: 466 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"serde\", \"std\"]","declared_features":"[\"default\", \"serde\", \"std\"]","target":10123455430689237779,"profile":2241668132362809309,"path":18224973447294848039,"deps":[[11899261697793765154,"serde",false,13761837835033900670]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/semver-407364a4d93478f4/dep-lib-semver","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde_core-6bb41266f991806c/lib-serde_core.json
РАЗМЕР: 487 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"alloc\", \"default\", \"rc\", \"result\", \"std\", \"unstable\"]","target":6810695588070812737,"profile":2241668132362809309,"path":9439545805731720344,"deps":[[11899261697793765154,"build_script_build",false,7144056772830625954]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_core-6bb41266f991806c/dep-lib-serde_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-7d39b878e003bf56/test-lib-uhpm_core.json
РАЗМЕР: 416 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":3316208278650011218,"path":10763286916239946207,"deps":[[18361894353739432590,"semver",false,14561842533847925745]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-7d39b878e003bf56/dep-test-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde_core-dea4fecf3d308a7b/run-build-script-build-script-build.json
РАЗМЕР: 331 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[11899261697793765154,"build_script_build",false,9525827378317755405]],"local":[{"RerunIfChanged":{"output":"debug/build/serde_core-dea4fecf3d308a7b/output","paths":["build.rs"]}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde_core-d784e5204f08362f/build-script-build-script-build.json
РАЗМЕР: 454 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"result\", \"std\"]","declared_features":"[\"alloc\", \"default\", \"rc\", \"result\", \"std\", \"unstable\"]","target":5408242616063297496,"profile":2225463790103693989,"path":1417144236825141019,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_core-d784e5204f08362f/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde-f38b255d54569d39/run-build-script-build-script-build.json
РАЗМЕР: 327 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[13548984313718623784,"build_script_build",false,17688500154066176716]],"local":[{"RerunIfChanged":{"output":"debug/build/serde-f38b255d54569d39/output","paths":["build.rs"]}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde-81f7362c921f3803/build-script-build-script-build.json
РАЗМЕР: 499 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"derive\", \"serde_derive\", \"std\"]","declared_features":"[\"alloc\", \"default\", \"derive\", \"rc\", \"serde_derive\", \"std\", \"unstable\"]","target":5408242616063297496,"profile":2225463790103693989,"path":14509020977942277527,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde-81f7362c921f3803/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde_derive-1cefe8f00fc96399/lib-serde_derive.json
РАЗМЕР: 579 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\"]","declared_features":"[\"default\", \"deserialize_in_place\"]","target":13076129734743110817,"profile":2225463790103693989,"path":1152709245822875513,"deps":[[5489675356391855191,"syn",false,11884103470740281247],[9869581871423326951,"quote",false,5800435558445652524],[14285738760999836560,"proc_macro2",false,4008135464488205713]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_derive-1cefe8f00fc96399/dep-lib-serde_derive","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/proc-macro2-212e1b436af8237f/lib-proc_macro2.json
РАЗМЕР: 563 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"proc-macro\"]","declared_features":"[\"default\", \"nightly\", \"proc-macro\", \"span-locations\"]","target":369203346396300798,"profile":2225463790103693989,"path":6947380262093086462,"deps":[[1548027836057496652,"unicode_ident",false,17409918438306662192],[14285738760999836560,"build_script_build",false,15068035285732670198]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/proc-macro2-212e1b436af8237f/dep-lib-proc_macro2","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/proc-macro2-4e36039c342c4436/run-build-script-build-script-build.json
РАЗМЕР: 488 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[14285738760999836560,"build_script_build",false,16265922915885609968]],"local":[{"RerunIfChanged":{"output":"debug/build/proc-macro2-4e36039c342c4436/output","paths":["src/probe/proc_macro_span.rs","src/probe/proc_macro_span_location.rs","src/probe/proc_macro_span_file.rs"]}},{"RerunIfEnvChanged":{"var":"RUSTC_BOOTSTRAP","val":null}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/proc-macro2-e66d8e1ef81553c8/build-script-build-script-build.json
РАЗМЕР: 446 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"proc-macro\"]","declared_features":"[\"default\", \"nightly\", \"proc-macro\", \"span-locations\"]","target":5408242616063297496,"profile":2225463790103693989,"path":16929279383227222793,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/proc-macro2-e66d8e1ef81553c8/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/unicode-ident-dcc4880ae369c77e/lib-unicode_ident.json
РАЗМЕР: 360 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":5438535436255082082,"profile":2225463790103693989,"path":11124477566800964721,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/unicode-ident-dcc4880ae369c77e/dep-lib-unicode_ident","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/quote-f976a12e37349547/lib-quote.json
РАЗМЕР: 517 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"proc-macro\"]","declared_features":"[\"default\", \"proc-macro\"]","target":3570458776599611685,"profile":2225463790103693989,"path":12833784984521330057,"deps":[[9869581871423326951,"build_script_build",false,12129838406033006271],[14285738760999836560,"proc_macro2",false,4008135464488205713]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/quote-f976a12e37349547/dep-lib-quote","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/quote-97c24d6996dcddb8/run-build-script-build-script-build.json
РАЗМЕР: 326 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[9869581871423326951,"build_script_build",false,13517548698972962392]],"local":[{"RerunIfChanged":{"output":"debug/build/quote-97c24d6996dcddb8/output","paths":["build.rs"]}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/quote-ead29afb18e9c68d/build-script-build-script-build.json
РАЗМЕР: 407 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"proc-macro\"]","declared_features":"[\"default\", \"proc-macro\"]","target":17883862002600103897,"profile":2225463790103693989,"path":2725913554714599045,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/quote-ead29afb18e9c68d/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/syn-dfb06a6ea9f263cb/lib-syn.json
РАЗМЕР: 749 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"clone-impls\", \"derive\", \"parsing\", \"printing\", \"proc-macro\"]","declared_features":"[\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"fold\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"test\", \"visit\", \"visit-mut\"]","target":9442126953582868550,"profile":2225463790103693989,"path":1873200233243139557,"deps":[[1548027836057496652,"unicode_ident",false,17409918438306662192],[9869581871423326951,"quote",false,5800435558445652524],[14285738760999836560,"proc_macro2",false,4008135464488205713]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/syn-dfb06a6ea9f263cb/dep-lib-syn","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-33f3ce6239e07a56/lib-uhpm_core.json
РАЗМЕР: 469 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":17672942494452627365,"path":10763286916239946207,"deps":[[13548984313718623784,"serde",false,18421650072715701969],[18361894353739432590,"semver",false,5181061862439470072]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-33f3ce6239e07a56/dep-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/semver-c28d73440eae2a92/lib-semver.json
РАЗМЕР: 465 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"serde\", \"std\"]","declared_features":"[\"default\", \"serde\", \"std\"]","target":10123455430689237779,"profile":2241668132362809309,"path":18224973447294848039,"deps":[[11899261697793765154,"serde",false,7168656750020458000]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/semver-c28d73440eae2a92/dep-lib-semver","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde_core-8ee7d9169f1fe44c/lib-serde_core.json
РАЗМЕР: 506 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"result\", \"std\"]","declared_features":"[\"alloc\", \"default\", \"rc\", \"result\", \"std\", \"unstable\"]","target":6810695588070812737,"profile":2241668132362809309,"path":9439545805731720344,"deps":[[11899261697793765154,"build_script_build",false,4588595964001119325]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_core-8ee7d9169f1fe44c/dep-lib-serde_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde-187a91c80447b824/lib-serde.json
РАЗМЕР: 674 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"derive\", \"serde_derive\", \"std\"]","declared_features":"[\"alloc\", \"default\", \"derive\", \"rc\", \"serde_derive\", \"std\", \"unstable\"]","target":11327258112168116673,"profile":2241668132362809309,"path":16667449090868358965,"deps":[[3051629642231505422,"serde_derive",false,13064075201006610564],[11899261697793765154,"serde_core",false,7168656750020458000],[13548984313718623784,"build_script_build",false,11964626768750277608]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde-187a91c80447b824/dep-lib-serde","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-506545ac4d3d689e/test-lib-uhpm_core.json
РАЗМЕР: 473 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":3316208278650011218,"path":10763286916239946207,"deps":[[13548984313718623784,"serde",false,18421650072715701969],[18361894353739432590,"semver",false,5181061862439470072]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-506545ac4d3d689e/dep-test-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde_derive-871ea2dbd1f8ec02/lib-serde_derive.json
РАЗМЕР: 578 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\"]","declared_features":"[\"default\", \"deserialize_in_place\"]","target":13076129734743110817,"profile":2225463790103693989,"path":1152709245822875513,"deps":[[5489675356391855191,"syn",false,9457989527501496980],[9869581871423326951,"quote",false,5759791221596750278],[14285738760999836560,"proc_macro2",false,1334938369389881704]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_derive-871ea2dbd1f8ec02/dep-lib-serde_derive","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/proc-macro2-5ed38b0d84d6dc0d/lib-proc_macro2.json
РАЗМЕР: 576 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"proc-macro\"]","declared_features":"[\"default\", \"nightly\", \"proc-macro\", \"span-locations\"]","target":369203346396300798,"profile":2225463790103693989,"path":6947380262093086462,"deps":[[1548027836057496652,"unicode_ident",false,17409918438306662192],[14285738760999836560,"build_script_build",false,13094088388039999748]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/proc-macro2-5ed38b0d84d6dc0d/dep-lib-proc_macro2","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/proc-macro2-dc5b59bf23e1cfb0/run-build-script-build-script-build.json
РАЗМЕР: 487 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[14285738760999836560,"build_script_build",false,5813399523453582992]],"local":[{"RerunIfChanged":{"output":"debug/build/proc-macro2-dc5b59bf23e1cfb0/output","paths":["src/probe/proc_macro_span.rs","src/probe/proc_macro_span_location.rs","src/probe/proc_macro_span_file.rs"]}},{"RerunIfEnvChanged":{"var":"RUSTC_BOOTSTRAP","val":null}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/proc-macro2-c2526afd3b95d9b7/build-script-build-script-build.json
РАЗМЕР: 459 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"proc-macro\"]","declared_features":"[\"default\", \"nightly\", \"proc-macro\", \"span-locations\"]","target":5408242616063297496,"profile":2225463790103693989,"path":16929279383227222793,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/proc-macro2-c2526afd3b95d9b7/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/quote-1da697092a95f2c2/lib-quote.json
РАЗМЕР: 530 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"proc-macro\"]","declared_features":"[\"default\", \"proc-macro\"]","target":3570458776599611685,"profile":2225463790103693989,"path":12833784984521330057,"deps":[[9869581871423326951,"build_script_build",false,17298055287573831071],[14285738760999836560,"proc_macro2",false,1334938369389881704]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/quote-1da697092a95f2c2/dep-lib-quote","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/quote-02f7696a962b13b7/run-build-script-build-script-build.json
РАЗМЕР: 326 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[9869581871423326951,"build_script_build",false,16115271054636261095]],"local":[{"RerunIfChanged":{"output":"debug/build/quote-02f7696a962b13b7/output","paths":["build.rs"]}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/quote-391472fcee49cce6/build-script-build-script-build.json
РАЗМЕР: 420 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"proc-macro\"]","declared_features":"[\"default\", \"proc-macro\"]","target":17883862002600103897,"profile":2225463790103693989,"path":2725913554714599045,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/quote-391472fcee49cce6/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/syn-6a83bb56d4d96d88/lib-syn.json
РАЗМЕР: 762 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"clone-impls\", \"default\", \"derive\", \"parsing\", \"printing\", \"proc-macro\"]","declared_features":"[\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"fold\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"test\", \"visit\", \"visit-mut\"]","target":9442126953582868550,"profile":2225463790103693989,"path":1873200233243139557,"deps":[[1548027836057496652,"unicode_ident",false,17409918438306662192],[9869581871423326951,"quote",false,5759791221596750278],[14285738760999836560,"proc_macro2",false,1334938369389881704]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/syn-6a83bb56d4d96d88/dep-lib-syn","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/thiserror-8d9485f38595e92d/run-build-script-build-script-build.json
РАЗМЕР: 394 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[4336745513838352383,"build_script_build",false,5924094808589297674]],"local":[{"RerunIfChanged":{"output":"debug/build/thiserror-8d9485f38595e92d/output","paths":["build/probe.rs"]}},{"RerunIfEnvChanged":{"var":"RUSTC_BOOTSTRAP","val":null}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/thiserror-55630d289fe835da/build-script-build-script-build.json
РАЗМЕР: 409 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"std\"]","declared_features":"[\"default\", \"std\"]","target":5408242616063297496,"profile":2225463790103693989,"path":7617312913555012781,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/thiserror-55630d289fe835da/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/thiserror-impl-49e0d13b8761e360/lib-thiserror_impl.json
РАЗМЕР: 532 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":6216210811039475267,"profile":2225463790103693989,"path":725425610358298478,"deps":[[5489675356391855191,"syn",false,9457989527501496980],[9869581871423326951,"quote",false,5759791221596750278],[14285738760999836560,"proc_macro2",false,1334938369389881704]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/thiserror-impl-49e0d13b8761e360/dep-lib-thiserror_impl","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-235f13d86f8ad482/lib-uhpm_core.json
РАЗМЕР: 529 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":17672942494452627365,"path":10763286916239946207,"deps":[[4336745513838352383,"thiserror",false,14661980808931050809],[13548984313718623784,"serde",false,8798923929575449198],[18361894353739432590,"semver",false,5181061862439470072]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-235f13d86f8ad482/dep-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde-71a22e0e72af713a/lib-serde.json
РАЗМЕР: 673 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"derive\", \"serde_derive\", \"std\"]","declared_features":"[\"alloc\", \"default\", \"derive\", \"rc\", \"serde_derive\", \"std\", \"unstable\"]","target":11327258112168116673,"profile":2241668132362809309,"path":16667449090868358965,"deps":[[3051629642231505422,"serde_derive",false,8466278102192678545],[11899261697793765154,"serde_core",false,7168656750020458000],[13548984313718623784,"build_script_build",false,11964626768750277608]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde-71a22e0e72af713a/dep-lib-serde","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/thiserror-d0007bbd87baeba2/lib-thiserror.json
РАЗМЕР: 528 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"std\"]","declared_features":"[\"default\", \"std\"]","target":13586076721141200315,"profile":2241668132362809309,"path":17334791267526063171,"deps":[[4336745513838352383,"build_script_build",false,14297017499235450399],[11901531446245070123,"thiserror_impl",false,4042279226148241105]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/thiserror-d0007bbd87baeba2/dep-lib-thiserror","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-1890b567f8d5d950/test-lib-uhpm_core.json
РАЗМЕР: 533 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":3316208278650011218,"path":10763286916239946207,"deps":[[4336745513838352383,"thiserror",false,14661980808931050809],[13548984313718623784,"serde",false,8798923929575449198],[18361894353739432590,"semver",false,5181061862439470072]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-1890b567f8d5d950/dep-test-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/async-trait-bb98e305740a7ee2/lib-async_trait.json
РАЗМЕР: 527 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":5116616278641129243,"profile":2225463790103693989,"path":3426920280990989189,"deps":[[5489675356391855191,"syn",false,7016378576185313642],[9869581871423326951,"quote",false,5759791221596750278],[14285738760999836560,"proc_macro2",false,1334938369389881704]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/async-trait-bb98e305740a7ee2/dep-lib-async_trait","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/syn-e5cf641a56dc5fbf/lib-syn.json
РАЗМЕР: 787 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"clone-impls\", \"default\", \"derive\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"visit-mut\"]","declared_features":"[\"clone-impls\", \"default\", \"derive\", \"extra-traits\", \"fold\", \"full\", \"parsing\", \"printing\", \"proc-macro\", \"test\", \"visit\", \"visit-mut\"]","target":9442126953582868550,"profile":2225463790103693989,"path":1873200233243139557,"deps":[[1548027836057496652,"unicode_ident",false,17409918438306662192],[9869581871423326951,"quote",false,5759791221596750278],[14285738760999836560,"proc_macro2",false,1334938369389881704]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/syn-e5cf641a56dc5fbf/dep-lib-syn","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde_derive-a8a9cb339fc78730/lib-serde_derive.json
РАЗМЕР: 578 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\"]","declared_features":"[\"default\", \"deserialize_in_place\"]","target":13076129734743110817,"profile":2225463790103693989,"path":1152709245822875513,"deps":[[5489675356391855191,"syn",false,7016378576185313642],[9869581871423326951,"quote",false,5759791221596750278],[14285738760999836560,"proc_macro2",false,1334938369389881704]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde_derive-a8a9cb339fc78730/dep-lib-serde_derive","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/thiserror-impl-33420cee1dc8d9ac/lib-thiserror_impl.json
РАЗМЕР: 532 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":6216210811039475267,"profile":2225463790103693989,"path":725425610358298478,"deps":[[5489675356391855191,"syn",false,7016378576185313642],[9869581871423326951,"quote",false,5759791221596750278],[14285738760999836560,"proc_macro2",false,1334938369389881704]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/thiserror-impl-33420cee1dc8d9ac/dep-lib-thiserror_impl","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-52cc9b8cbb550893/lib-uhpm_core.json
РАЗМЕР: 593 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":17672942494452627365,"path":10763286916239946207,"deps":[[4336745513838352383,"thiserror",false,1093448694492413057],[13548984313718623784,"serde",false,12689308175699160687],[16611674984963787466,"async_trait",false,10300731548042896552],[18361894353739432590,"semver",false,5181061862439470072]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-52cc9b8cbb550893/dep-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/serde-1ee3c93e3c647db6/lib-serde.json
РАЗМЕР: 673 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"derive\", \"serde_derive\", \"std\"]","declared_features":"[\"alloc\", \"default\", \"derive\", \"rc\", \"serde_derive\", \"std\", \"unstable\"]","target":11327258112168116673,"profile":2241668132362809309,"path":16667449090868358965,"deps":[[3051629642231505422,"serde_derive",false,5291268848647290374],[11899261697793765154,"serde_core",false,7168656750020458000],[13548984313718623784,"build_script_build",false,11964626768750277608]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/serde-1ee3c93e3c647db6/dep-lib-serde","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/thiserror-51b0fa06c8f35423/lib-thiserror.json
РАЗМЕР: 528 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"std\"]","declared_features":"[\"default\", \"std\"]","target":13586076721141200315,"profile":2241668132362809309,"path":17334791267526063171,"deps":[[4336745513838352383,"build_script_build",false,14297017499235450399],[11901531446245070123,"thiserror_impl",false,4994499578667793834]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/thiserror-51b0fa06c8f35423/dep-lib-thiserror","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-906224bfc2ff2ea6/test-lib-uhpm_core.json
РАЗМЕР: 597 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":3316208278650011218,"path":10763286916239946207,"deps":[[4336745513838352383,"thiserror",false,1093448694492413057],[13548984313718623784,"serde",false,12689308175699160687],[16611674984963787466,"async_trait",false,10300731548042896552],[18361894353739432590,"semver",false,5181061862439470072]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-906224bfc2ff2ea6/dep-test-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/num-traits-607b561f926e0b31/run-build-script-build-script-build.json
РАЗМЕР: 330 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[5157631553186200874,"build_script_build",false,6566158712416974105]],"local":[{"RerunIfChanged":{"output":"debug/build/num-traits-607b561f926e0b31/output","paths":["build.rs"]}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/num-traits-5967db0e4a21fe12/build-script-build-script-build.json
РАЗМЕР: 469 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"default\", \"i128\", \"libm\", \"std\"]","target":5408242616063297496,"profile":2225463790103693989,"path":6636377057750529524,"deps":[[13927012481677012980,"autocfg",false,11882755885410638133]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-traits-5967db0e4a21fe12/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/autocfg-e43f4f6a57543659/lib-autocfg.json
РАЗМЕР: 347 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":6962977057026645649,"profile":2225463790103693989,"path":8642536385914181017,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/autocfg-e43f4f6a57543659/dep-lib-autocfg","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/chrono-2ef7b90349b4d26c/lib-chrono.json
РАЗМЕР: 1047 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"alloc\", \"clock\", \"default\", \"iana-time-zone\", \"js-sys\", \"now\", \"oldtime\", \"serde\", \"std\", \"wasm-bindgen\", \"wasmbind\", \"winapi\", \"windows-link\"]","declared_features":"[\"__internal_bench\", \"alloc\", \"arbitrary\", \"clock\", \"core-error\", \"default\", \"iana-time-zone\", \"js-sys\", \"libc\", \"now\", \"oldtime\", \"pure-rust-locales\", \"rkyv\", \"rkyv-16\", \"rkyv-32\", \"rkyv-64\", \"rkyv-validation\", \"serde\", \"std\", \"unstable-locales\", \"wasm-bindgen\", \"wasmbind\", \"winapi\", \"windows-link\"]","target":15315924755136109342,"profile":2241668132362809309,"path":6871470700040881915,"deps":[[5157631553186200874,"num_traits",false,17738116866471495457],[12317487911761266689,"iana_time_zone",false,7907944063347062327],[13548984313718623784,"serde",false,12689308175699160687]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/chrono-2ef7b90349b4d26c/dep-lib-chrono","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/iana-time-zone-250791ca2b0fd0fd/lib-iana_time_zone.json
РАЗМЕР: 386 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"fallback\"]","declared_features":"[\"fallback\"]","target":13492157405369956366,"profile":2241668132362809309,"path":7407481652264594575,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/iana-time-zone-250791ca2b0fd0fd/dep-lib-iana_time_zone","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/num-traits-f97bee2f1fb7c0d5/lib-num_traits.json
РАЗМЕР: 462 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"default\", \"i128\", \"libm\", \"std\"]","target":4278088450330190724,"profile":2241668132362809309,"path":7198440833724197830,"deps":[[5157631553186200874,"build_script_build",false,10967265841631580434]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/num-traits-f97bee2f1fb7c0d5/dep-lib-num_traits","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uuid-ac2ac7f1eeb6bcb4/lib-uuid.json
РАЗМЕР: 659 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"std\"]","declared_features":"[\"arbitrary\", \"atomic\", \"borsh\", \"bytemuck\", \"default\", \"fast-rng\", \"js\", \"macro-diagnostics\", \"md5\", \"rng\", \"rng-getrandom\", \"rng-rand\", \"serde\", \"sha1\", \"slog\", \"std\", \"uuid-rng-internal-lib\", \"v1\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\", \"v8\", \"zerocopy\"]","target":10485754080552990909,"profile":13283718623888339653,"path":6111036676009996668,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uuid-ac2ac7f1eeb6bcb4/dep-lib-uuid","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/getrandom-8b77c37f53000e72/run-build-script-build-script-build.json
РАЗМЕР: 331 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[18408407127522236545,"build_script_build",false,15982193352925960829]],"local":[{"RerunIfChanged":{"output":"debug/build/getrandom-8b77c37f53000e72/output","paths":["build.rs"]}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/getrandom-e5ac4d83c21b9f00/build-script-build-script-build.json
РАЗМЕР: 389 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"std\", \"wasm_js\"]","target":5408242616063297496,"profile":9077819541049765386,"path":6809656771296094483,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/getrandom-e5ac4d83c21b9f00/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/libc-478a792d6f0156d0/run-build-script-build-script-build.json
РАЗМЕР: 717 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[11499138078358568213,"build_script_build",false,11674856053222415768]],"local":[{"RerunIfChanged":{"output":"debug/build/libc-478a792d6f0156d0/output","paths":["build.rs"]}},{"RerunIfEnvChanged":{"var":"RUST_LIBC_UNSTABLE_FREEBSD_VERSION","val":null}},{"RerunIfEnvChanged":{"var":"RUST_LIBC_UNSTABLE_MUSL_V1_2_3","val":null}},{"RerunIfEnvChanged":{"var":"RUST_LIBC_UNSTABLE_LINUX_TIME_BITS64","val":null}},{"RerunIfEnvChanged":{"var":"RUST_LIBC_UNSTABLE_GNU_FILE_OFFSET_BITS","val":null}},{"RerunIfEnvChanged":{"var":"RUST_LIBC_UNSTABLE_GNU_TIME_BITS","val":null}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/libc-c74016bd0144e90e/build-script-build-script-build.json
РАЗМЕР: 499 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"align\", \"const-extern-fn\", \"default\", \"extra_traits\", \"rustc-dep-of-std\", \"rustc-std-workspace-core\", \"std\", \"use_std\"]","target":5408242616063297496,"profile":1565149285177326037,"path":1586463303832073585,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/libc-c74016bd0144e90e/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uuid-3e839ccab5991f6e/lib-uuid.json
РАЗМЕР: 737 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"rng\", \"std\", \"v4\"]","declared_features":"[\"arbitrary\", \"atomic\", \"borsh\", \"bytemuck\", \"default\", \"fast-rng\", \"js\", \"macro-diagnostics\", \"md5\", \"rng\", \"rng-getrandom\", \"rng-rand\", \"serde\", \"sha1\", \"slog\", \"std\", \"uuid-rng-internal-lib\", \"v1\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\", \"v8\", \"zerocopy\"]","target":10485754080552990909,"profile":13283718623888339653,"path":6111036676009996668,"deps":[[18408407127522236545,"getrandom",false,14702056783504429647]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uuid-3e839ccab5991f6e/dep-lib-uuid","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/getrandom-f99e369581e1dacd/lib-getrandom.json
РАЗМЕР: 557 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"std\", \"wasm_js\"]","target":11669924403970522481,"profile":10402231138261309960,"path":2828682946281154601,"deps":[[7667230146095136825,"cfg_if",false,11291588380199723018],[11499138078358568213,"libc",false,11964631176781080663],[18408407127522236545,"build_script_build",false,8206784540649638724]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/getrandom-f99e369581e1dacd/dep-lib-getrandom","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/cfg-if-0d06577c98329a83/lib-cfg_if.json
РАЗМЕР: 377 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"core\", \"rustc-dep-of-std\"]","target":13840298032947503755,"profile":2241668132362809309,"path":12787743209565792249,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/cfg-if-0d06577c98329a83/dep-lib-cfg_if","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/libc-69720a83dc49ea96/lib-libc.json
РАЗМЕР: 548 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"align\", \"const-extern-fn\", \"default\", \"extra_traits\", \"rustc-dep-of-std\", \"rustc-std-workspace-core\", \"std\", \"use_std\"]","target":17682796336736096309,"profile":15222631470922254920,"path":9582348871343213566,"deps":[[11499138078358568213,"build_script_build",false,10245934914816830009]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/libc-69720a83dc49ea96/dep-lib-libc","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/generic-array-2c9aed73dfffed49/run-build-script-build-script-build.json
РАЗМЕР: 258 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[10520923840501062997,"build_script_build",false,5467225634875897792]],"local":[{"Precalculated":"0.14.7"}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/generic-array-f2f2607b090a65d5/build-script-build-script-build.json
РАЗМЕР: 494 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"more_lengths\"]","declared_features":"[\"more_lengths\", \"serde\", \"zeroize\"]","target":12318548087768197662,"profile":2225463790103693989,"path":1114357588343196578,"deps":[[5398981501050481332,"version_check",false,11756078771894400840]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/generic-array-f2f2607b090a65d5/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/version_check-ea6887218707dfc6/lib-version_check.json
РАЗМЕР: 360 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":18099224280402537651,"profile":2225463790103693989,"path":2116558336377015614,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/version_check-ea6887218707dfc6/dep-lib-version_check","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/typenum-f68f558ad7616dfe/run-build-script-build-script-build.json
РАЗМЕР: 323 байт
==========================================
{"rustc":16285725380928457773,"features":"","declared_features":"","target":0,"profile":0,"path":0,"deps":[[857979250431893282,"build_script_build",false,1024324405104309666]],"local":[{"RerunIfChanged":{"output":"debug/build/typenum-f68f558ad7616dfe/output","paths":["tests"]}}],"rustflags":[],"config":0,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/typenum-40d4fdd79c1383cd/build-script-build-script-build.json
РАЗМЕР: 483 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[\"const-generics\", \"force_unix_path_separator\", \"i128\", \"no_std\", \"scale-info\", \"scale_info\", \"strict\"]","target":17883862002600103897,"profile":2225463790103693989,"path":3204412154239618668,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/typenum-40d4fdd79c1383cd/dep-build-script-build-script-build","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/uhpm-core-1b105df5ed91e57b/lib-uhpm_core.json
РАЗМЕР: 873 байт
==========================================
{"rustc":16285725380928457773,"features":"[]","declared_features":"[]","target":15004106216738993522,"profile":17672942494452627365,"path":10763286916239946207,"deps":[[503842845364652431,"chrono",false,4322577840606243112],[4336745513838352383,"thiserror",false,1093448694492413057],[9857275760291862238,"sha2",false,7746577577165529390],[10724389056617919257,"sha1",false,11300093620033441769],[13548984313718623784,"serde",false,12689308175699160687],[15267671913832104935,"uuid",false,7786664844329053357],[16611674984963787466,"async_trait",false,10300731548042896552],[17548070434322971711,"md5",false,16843762804508635039],[18361894353739432590,"semver",false,5181061862439470072]],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/uhpm-core-1b105df5ed91e57b/dep-lib-uhpm_core","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

==========================================
ФАЙЛ: ./target/debug/.fingerprint/md5-c60aa1bc3376f101/lib-md5.json
РАЗМЕР: 380 байт
==========================================
{"rustc":16285725380928457773,"features":"[\"default\", \"std\"]","declared_features":"[\"default\", \"std\"]","target":6337943835233403857,"profile":2241668132362809309,"path":15413542098262137530,"deps":[],"local":[{"CheckDepInfo":{"dep_info":"debug/.fingerprint/md5-c60aa1bc3376f101/dep-lib-md5","checksum":false}}],"rustflags":[],"config":2069994364910194474,"compile_kind":0}

